scn TMHealthTokenS

float fTemp
float fHealthFraction
ref container
float xMax
float x ;x represents health
float fStartBleedValue
float deathTimer
float targetHealth
float previousHealth
float fStartRegenValue
float fullHealthTimer

begin _GameMode
	if eval !Call CFIsTokenStable
		return
	elseif eval (Call CFStandardTokenRemovalCheck) || !TMHealthQst.bEnableBleedAndRegen
		RemoveMe
	endif

	set container to GetContainer

	if eval ShouldLog LogLevelFlooding
		if eval container == PlayerRef
			Logf "----TMHealthTokenS. container:" +$container
		endif
	endif

	Let xMax := (Call CFGetAVMax container avcHealth) -1 ; You die when you reach < 1 health, so we'll adjust by -1
	Let x := ((Call CFGetAVCurrent container avcHealth) -1) ; You die when you reach < 1 health, so we'll adjust by -1
	Let fHealthFraction := x / xMax

	if eval (fHealthFraction < TMHealthQst.startBleedHealthFraction)
		if eval (TMHealthQst.secondsUntilDeathFromBleedHealthPercentage == 0)
			Loge "invalid secondsUntilDeathFromBleedHealthPercentage:" + $TMHealthQst.secondsUntilDeathFromBleedHealthPercentage
			return
		endif
		Let fStartBleedValue := TMHealthQst.startBleedHealthFraction * xMax

		if previousHealth != x
			;t = x * SUD / SBV
			Let deathTimer := TMHealthQst.secondsUntilDeathFromBleedHealthPercentage * x / fStartBleedValue
			if eval ShouldLog LogLevelFlooding
				if eval container == PlayerRef
					Logf "QAZ. previousHealth:"+$previousHealth+" (GetActorValueC avcHealth):"+$(GetActorValueC avcHealth)+" deathTimer:"+$deathTimer+" secondsMult:"+$TMHealthQst.secondsMult
				endif
			endif
		endif

		Let deathTimer -= GetSecondsPassed * TMHealthQst.secondsMult
		
		if (deathTimer <= 0)
			; Might not be necessary..
			Let targetHealth := 0
		else
			; Solving for x (targetHealth) because solving for dx can get inaccurate due to lack of precision.
			Let targetHealth := (deathTimer / TMHealthQst.secondsUntilDeathFromBleedHealthPercentage) * fStartBleedValue + 1
		endif

		if eval ShouldLog LogLevelFlooding
			if eval container == PlayerRef
				Logf "deathTimer:"+$deathTimer+" targetHealth:"+$targetHealth+" previousHealth:"+$previousHealth
			endif
		endif

		Call CFSetAVCurrent container avcHealth targetHealth
	endif
	if eval (fHealthFraction > TMHealthQst.startRegenHealthFraction)
		if eval (TMHealthQst.secondsUntilFullHealthFromRegenHealthPercentage == 0)
			Loge "invalid secondsUntilFullHealthFromRegenHealthPercentage:" + $TMHealthQst.secondsUntilFullHealthFromRegenHealthPercentage
			return
		endif
		Let fStartRegenValue := TMHealthQst.startRegenHealthFraction * xMax

		if previousHealth != x
			;t = (xMax - x) * SUFH / (xMax - SRV)
			Let fullHealthTimer := (xMax - x) * TMHealthQst.secondsUntilFullHealthFromRegenHealthPercentage / (xMax - fStartRegenValue)
			if eval ShouldLog LogLevelFlooding
				if eval container == PlayerRef
					Logf "ZAQ. previousHealth:"+$previousHealth+" (GetActorValueC avcHealth):"+$(GetActorValueC avcHealth)+" fullHealthTimer:"+$fullHealthTimer+" TMHealthQst.secondsMult:"+$TMHealthQst.secondsMult
				endif
			endif
		endif

		Let fullHealthTimer -= GetSecondsPassed * TMHealthQst.secondsMult
		Let fullHealthTimer := Call CFMax 0 fullHealthTimer
		
		; Solving for x (targetHealth) because solving for dx can get inaccurate due to lack of precision.
		Let targetHealth := xMax - (xMax - fStartRegenValue)*(fullHealthTimer / TMHealthQst.secondsUntilFullHealthFromRegenHealthPercentage) + 1

		if eval ShouldLog LogLevelFlooding
			if eval container == PlayerRef
				Logf "fullHealthTimer:"+$fullHealthTimer+" targetHealth:"+$targetHealth+" previousHealth:"+$previousHealth
			endif
		endif

		Call CFSetAVCurrent container avcHealth targetHealth
	endif
	if eval ShouldLog LogLevelFlooding
		if eval container == PlayerRef && (TMHealthQst.startBleedHealthFraction <= fHealthFraction) && (fHealthFraction <= TMHealthQst.startRegenHealthFraction)
			Logf "Neither bleeding nor regenerating"
		endif
	endif
	Let previousHealth := (Call CFGetAVCurrent container avcHealth) -1
end