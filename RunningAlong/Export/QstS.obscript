scn QstS

float fQuestDelayTime


float secondsUntilFullRegenWhileStandingIfCompletelyFit
float secondsUntilFullRegenWhileWalkingIfCompletelyFit
float secondsUntilFullRegenWhileRunningIfCompletelyFit
float secondsUntilFullRegenWhileSprintingIfCompletelyFit
float secondsUntilFullRegenWhileStandingIfCompletelyNotFit
float secondsUntilFullRegenWhileWalkingIfCompletelyNotFit
float secondsUntilFullRegenWhileRunningIfCompletelyNotFit
float secondsUntilFullRegenWhileSprintingIfCompletelyNotFit
float fFitMult
float secondsUntilFullRegen
float fFatigueRegen
int iPreviousAVMax
int iCountDownAfterMenuMode
array_var iter
short iFitSkillCount
int avMax
short bRecentlyFell
float fRecentlyJumpedWhileSprintingTimer

begin _GameMode
	SetModLogLevel LogLevelWarning ;There might be a better place to define this
	;Disabled ControlIDRunWalk so that it can act as a sprint mechanism instead
	DisableControl ControlIDRunWalk
	; # Given walking When sprint key pressed Then untoggle walk
	if eval (iCountDownAfterMenuMode >=0) ;This is a workaround to solve an issue where the control would be tapped when coming out of MenuMode and control is pressed
		Let iCountDownAfterMenuMode -= 1
	elseif eval (!PlayerRef.IsRunning) && IsEngaged ControlIDRunWalk
		TapControl ControlIDToggleRunWalk
	endif
	; # Define bStanding, bWalking, bRunning, bSprinting
	if eval ((!IsEngaged ControlIDForward) && (!IsEngaged ControlIDBack) && (!IsEngaged ControlIDLeft) && (!IsEngaged ControlIDRight)) || PlayerRef.IsRidingHorse
		Let SB.bStanding := 1
		Let SB.bWalking := 0
		Let SB.bRunning := 0
		Let SB.bSprinting := 0
	elseif eval !PlayerRef.IsRunning
		Let SB.bStanding := 0
		Let SB.bWalking := 1
		Let SB.bRunning := 0
		Let SB.bSprinting := 0
	elseif eval ((!IsEngaged ControlIDRunWalk) || IsEngaged ControlIDBack || IsEngaged ControlIDLeft || IsEngaged ControlIDRight) && (fRecentlyJumpedWhileSprintingTimer <= 0)
		Let SB.bStanding := 0
		Let SB.bWalking := 0
		Let SB.bRunning := 1
		Let SB.bSprinting := 0
	else
		Let SB.bStanding := 0
		Let SB.bWalking := 0
		Let SB.bRunning := 0
		Let SB.bSprinting := 1
	endif
	if eval fRecentlyJumpedWhileSprintingTimer > 0
		if eval PlayerRef.IsInAir && (fRecentlyJumpedWhileSprintingTimer > 0.3)
			Let fRecentlyJumpedWhileSprintingTimer -= GetSecondsPassed
		else
			Let fRecentlyJumpedWhileSprintingTimer := 0
		endif
	endif
	if eval PlayerRef.IsJumping && SB.bSprinting
		let fRecentlyJumpedWhileSprintingTimer := 2
	endif
	; # Speed Adjustments
	;I'm not sure if SetAVModC is the best way to adjust Speed
	;Using a flat value instead of % to prevent multiplicativeness
	;You might need AVUncapper so that values above 100 have an effect
	if eval SB.bSprinting
		PlayerRef.SetAVModC avcSpeed "script" 50
	else
		PlayerRef.SetAVModC avcSpeed "script" 0
	endif
	; # Define fFitMult
	Logf "====== Define fFitMult ======"
	;At some point, it might be a good idea to define fFitMult in CommonFunction's SB (ShareBox), so that multiple mods have access.
	;It would also be a good idea to calculate this less often, perhaps every 5s.
	;I'm not sure if creating arrays like this can cause memory leaks.
	;Using iPreviousValue so that, for example, if the player has all skills at 100, it considers them completely fit.
	Let iFitSkillCount := 0
	Let iPreviousAVMax := 0
	ForEach iter <- ar_CustomSort (ar_List avcAthletics, avcBlade, avcBlock, avcBlunt, avcHandToHand, avcHeavyArmor, avcAlchemy, avcAlteration, avcConjuration, avcDestruction, avcIllusion, avcMysticism, avcRestoration, avcAcrobatics, avcLightArmor, avcMarksman, avcMercantile, avcSecurity, avcSneak, avcSpeechcraft) ActorValueComparator 1
		Let avMax := Call CFGetAVMax PlayerRef iter["Value"]
		if eval (ShouldLog LogLevelFlooding)
			Logf "i:" +$iter["Key"] +" avc:" +$iter["Value"] +" avMax:" +$avMax +" iPreviousAVMax:" +$iPreviousAVMax
		endif
		if eval ((avMax <= 5) || (iter["Key"] >= 6 && iPreviousAVMax != avMax))
			break
		elseif eval (-99999.0 != ar_Find iter["Value"] (ar_List avcAthletics, avcBlade, avcBlock, avcBlunt, avcHandToHand, avcHeavyArmor, avcAcrobatics, avcLightArmor, avcMarksman, avcSneak))
			if eval (ShouldLog LogLevelFlooding)
				Logf "Found matching avc:" +$iter["Value"]+ " avMax:" + $avMax
			endif
			Let iFitSkillCount += 1
			if eval (ShouldLog LogLevelFlooding)
				Logf "iFitSkillCount is now:" +$iFitSkillCount
				if eval iter["Key"] >= 6
					Logf "iter[Key] >= 6:"+$(Call NarrateSL &(iter["Key"] >= 6))
					Logf "iPreviousAVMax != avMax:"+$(iPreviousAVMax != avMax)
				endif
			endif
			Let iPreviousAVMax := Call CFGetAVMax PlayerRef iter["Value"]
		endif
	loop
	if eval (ShouldLog LogLevelFlooding)
		Logf "iFitSkillCount:" +$iFitSkillCount
	endif
	Let fFitMult := Call WithinRange 0 (iFitSkillCount / 6) 1
	if eval (ShouldLog LogLevelFlooding)
		Logf "fFitMult:" +$fFitMult
	endif
	; # When fatigue is very low Then fall
	if eval ((PlayerRef.GetAVC avcFatigue) < 3) && !bRecentlyFell
		let bRecentlyFell := 1
		Call CFSetAVCurrent PlayerRef avcFatigue (-1000) ;Negative fatigue causes the actor to fall.
		Call Delay 3 PostFallWaiter ar_Null
		Call Delay 6 PostFallWaiter2 ar_Null
	endif
	; # Fatigue Regen
	;If GetSecondsPassed is big, it means the player waited or something. Just regen all of it.
	if (GetSecondsPassed > 20)
		Let fFatigueRegen := 10000
	else
		if SB.bWalking
			Let secondsUntilFullRegen := secondsUntilFullRegenWhileWalkingIfCompletelyNotFit + (secondsUntilFullRegenWhileWalkingIfCompletelyFit - secondsUntilFullRegenWhileWalkingIfCompletelyNotFit) * fFitMult
		elseif SB.bRunning
			Let secondsUntilFullRegen := secondsUntilFullRegenWhileRunningIfCompletelyNotFit + (secondsUntilFullRegenWhileRunningIfCompletelyFit - secondsUntilFullRegenWhileRunningIfCompletelyNotFit) * fFitMult
		elseif SB.bSprinting
			Let secondsUntilFullRegen := secondsUntilFullRegenWhileSprintingIfCompletelyNotFit + (secondsUntilFullRegenWhileSprintingIfCompletelyFit - secondsUntilFullRegenWhileSprintingIfCompletelyNotFit) * fFitMult
		else ; SB.bStanding
			Let secondsUntilFullRegen := secondsUntilFullRegenWhileStandingIfCompletelyNotFit + (secondsUntilFullRegenWhileStandingIfCompletelyFit - secondsUntilFullRegenWhileStandingIfCompletelyNotFit) * fFitMult
		endif
		Let fFatigueRegen := (Call CFGetAVBase PlayerRef 10) * GetSecondsPassed / secondsUntilFullRegen
		;Need to compensate for fFatigueReturnBase, fFatigueRunBase
		;(Those GameSettings cannot be adjusted without affecting NPCs.)
		Let fFatigueRegen -= GetSecondsPassed * (GetGameSetting "fFatigueReturnBase")
		if PlayerRef.IsRunning && (PlayerRef.IsMovingForward || PlayerRef.IsMovingBackward || PlayerRef.IsMovingLeft || PlayerRef.IsMovingRight)
			Let fFatigueRegen += GetSecondsPassed * (GetGameSetting "fFatigueRunBase")
		endif
	endif
	PlayerRef.ModAVModC avcFatigue "Damage" fFatigueRegen
end

begin _MenuMode
	Let iCountDownAfterMenuMode := 10
end